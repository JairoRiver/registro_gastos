// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: entry.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createEntry = `-- name: CreateEntry :one
INSERT INTO "Entry" (
  user_id,
  group_id,
  type_id,
  name,
  use_day,
  amount,
  cost,
  cost_indicator,
  place
) VALUES (
  $1, $2, $3, $4, $5,$6, $7, $8, $9
) RETURNING id, user_id, group_id, type_id, name, use_day, amount, cost, cost_indicator, place, created_at, updated_at
`

type CreateEntryParams struct {
	UserID        uuid.NullUUID  `json:"user_id"`
	GroupID       uuid.NullUUID  `json:"group_id"`
	TypeID        uuid.NullUUID  `json:"type_id"`
	Name          string         `json:"name"`
	UseDay        time.Time      `json:"use_day"`
	Amount        float64        `json:"amount"`
	Cost          float64        `json:"cost"`
	CostIndicator sql.NullString `json:"cost_indicator"`
	Place         string         `json:"place"`
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error) {
	row := q.db.QueryRowContext(ctx, createEntry,
		arg.UserID,
		arg.GroupID,
		arg.TypeID,
		arg.Name,
		arg.UseDay,
		arg.Amount,
		arg.Cost,
		arg.CostIndicator,
		arg.Place,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.TypeID,
		&i.Name,
		&i.UseDay,
		&i.Amount,
		&i.Cost,
		&i.CostIndicator,
		&i.Place,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEntry = `-- name: DeleteEntry :exec
DELETE FROM "Entry"
WHERE id = $1
`

func (q *Queries) DeleteEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEntry, id)
	return err
}

const getEntry = `-- name: GetEntry :one
SELECT en.id
      ,en.user_id
      ,en.group_id
      ,en.use_day
      ,en.name 
      ,ty.name as type
      ,en.amount
      ,en.cost
      ,en.cost_indicator
      ,en.place
FROM "Entry" as en
JOIN "Type" as ty on ty.id = en.type_id
WHERE en.id = $1 
LIMIT 1
`

type GetEntryRow struct {
	ID            uuid.UUID      `json:"id"`
	UserID        uuid.NullUUID  `json:"user_id"`
	GroupID       uuid.NullUUID  `json:"group_id"`
	UseDay        time.Time      `json:"use_day"`
	Name          string         `json:"name"`
	Type          string         `json:"type"`
	Amount        float64        `json:"amount"`
	Cost          float64        `json:"cost"`
	CostIndicator sql.NullString `json:"cost_indicator"`
	Place         string         `json:"place"`
}

func (q *Queries) GetEntry(ctx context.Context, id uuid.UUID) (GetEntryRow, error) {
	row := q.db.QueryRowContext(ctx, getEntry, id)
	var i GetEntryRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.UseDay,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.Cost,
		&i.CostIndicator,
		&i.Place,
	)
	return i, err
}

const listEntryByGroup = `-- name: ListEntryByGroup :many
SELECT en.id
      ,en.user_id
      ,en.group_id
      ,en.use_day
      ,en.name 
      ,ty.name as type
      ,en.amount
      ,en.cost
      ,en.cost_indicator
      ,en.place
FROM "Entry" as en
JOIN "Type" as ty on ty.id = en.type_id
WHERE en.group_id = $1
`

type ListEntryByGroupRow struct {
	ID            uuid.UUID      `json:"id"`
	UserID        uuid.NullUUID  `json:"user_id"`
	GroupID       uuid.NullUUID  `json:"group_id"`
	UseDay        time.Time      `json:"use_day"`
	Name          string         `json:"name"`
	Type          string         `json:"type"`
	Amount        float64        `json:"amount"`
	Cost          float64        `json:"cost"`
	CostIndicator sql.NullString `json:"cost_indicator"`
	Place         string         `json:"place"`
}

func (q *Queries) ListEntryByGroup(ctx context.Context, groupID uuid.NullUUID) ([]ListEntryByGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, listEntryByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEntryByGroupRow{}
	for rows.Next() {
		var i ListEntryByGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.UseDay,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.Cost,
			&i.CostIndicator,
			&i.Place,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntryByUser = `-- name: ListEntryByUser :many
SELECT en.id
      ,en.user_id
      ,en.group_id
      ,en.use_day
      ,en.name 
      ,ty.name as type
      ,en.amount
      ,en.cost
      ,en.cost_indicator
      ,en.place
FROM "Entry" as en
JOIN "Type" as ty on ty.id = en.type_id
WHERE en.user_id = $1
`

type ListEntryByUserRow struct {
	ID            uuid.UUID      `json:"id"`
	UserID        uuid.NullUUID  `json:"user_id"`
	GroupID       uuid.NullUUID  `json:"group_id"`
	UseDay        time.Time      `json:"use_day"`
	Name          string         `json:"name"`
	Type          string         `json:"type"`
	Amount        float64        `json:"amount"`
	Cost          float64        `json:"cost"`
	CostIndicator sql.NullString `json:"cost_indicator"`
	Place         string         `json:"place"`
}

func (q *Queries) ListEntryByUser(ctx context.Context, userID uuid.NullUUID) ([]ListEntryByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listEntryByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEntryByUserRow{}
	for rows.Next() {
		var i ListEntryByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.UseDay,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.Cost,
			&i.CostIndicator,
			&i.Place,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntry = `-- name: UpdateEntry :one
UPDATE "Entry"
SET
  user_id = COALESCE($1, user_id),
  updated_at = NOW(),
  group_id = COALESCE($2, group_id),
  type_id = COALESCE($3, type_id),
  name = COALESCE($4, name),
  use_day = COALESCE($5, use_day),
  amount = COALESCE($6, amount),
  cost = COALESCE($7, cost),
  cost_indicator = COALESCE($8, cost_indicator),
  place = COALESCE($9, place)
WHERE
  id = $10
RETURNING id, user_id, group_id, type_id, name, use_day, amount, cost, cost_indicator, place, created_at, updated_at
`

type UpdateEntryParams struct {
	UserID        uuid.NullUUID   `json:"user_id"`
	GroupID       uuid.NullUUID   `json:"group_id"`
	TypeID        uuid.NullUUID   `json:"type_id"`
	Name          sql.NullString  `json:"name"`
	UseDay        sql.NullTime    `json:"use_day"`
	Amount        sql.NullFloat64 `json:"amount"`
	Cost          sql.NullFloat64 `json:"cost"`
	CostIndicator sql.NullString  `json:"cost_indicator"`
	Place         sql.NullString  `json:"place"`
	ID            uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateEntry(ctx context.Context, arg UpdateEntryParams) (Entry, error) {
	row := q.db.QueryRowContext(ctx, updateEntry,
		arg.UserID,
		arg.GroupID,
		arg.TypeID,
		arg.Name,
		arg.UseDay,
		arg.Amount,
		arg.Cost,
		arg.CostIndicator,
		arg.Place,
		arg.ID,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.TypeID,
		&i.Name,
		&i.UseDay,
		&i.Amount,
		&i.Cost,
		&i.CostIndicator,
		&i.Place,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
